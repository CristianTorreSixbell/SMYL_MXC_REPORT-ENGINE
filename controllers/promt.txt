 tengo esta clase tipo controller que ejecuta un sp dentro de una base de datos 
 el cual inserta datos dentro de una tabla en esta base de datos.
 ``` js
 import sql from 'mssql'; 
import { chargeData } from '../lib/dotenvExtractor.js';
import cron from 'node-cron';
import logger from '../lib/Logger.js';
import dayjs from 'dayjs';
import timezone  from 'dayjs/plugin/timezone.js'; 
import utc from 'dayjs/plugin/utc.js';
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.tz.setDefault('America/Chicago');
         
const fechaMexico = dayjs().subtract(6,'hours').format("YYYY-MM-DDTHH:mm:ss.SSSZ");
chargeData();

class ExectSp{
    constructor(){
        this.logEvent = (type, event, submoduleInd) => {
            const submodules = ['MAIN'];
            const moduleName = 'EXEC_SP';
            const submodule = parseInt(submoduleInd) ? `][${submodules[parseInt(submoduleInd)]}` : '';
            if (type.toLowerCase().includes('error')) {
                logger.error(`[${moduleName}${submodule}(${type})]: ${event}`);
                return;
            }
            if (type.toLowerCase().includes('info')) {
                logger.info(`[${moduleName}${submodule}(${type})]: ${event}`);
                return;
            }
            if (type.toLowerCase().includes('warn')) {
                logger.warn(`[${moduleName}${submodule}(${type})]: ${event}`);
                return;
            } else {
                logger.warn(`[${moduleName}${submodule}(${type})]: ${event}\n(Error en tipificación de log)`);
                return;
            }
        };
    }

    async exectSp(req,res){
        try {
            cron.schedule( process.argv[15], async () => {            
                try{
                    this.logEvent('INFO', 'Ejecutando SP', 0);
                    const request = new sql.Request();
                    const dateToInyect1=dayjs(fechaMexico).add(6,'hours').subtract(1,'day').format("YYYY-MM-DD HH:mm:ss");// día actual -1
                    const dateToInyect2=dayjs(fechaMexico).add(6,'hours').subtract(2,'day').format("YYYY-MM-DD HH:mm:ss");// día actual -2
                    this.logEvent('INFO', `Fecha actual(UTC-6): ${fechaMexico} `, 0);
                    this.logEvent('INFO', `Ejecutando SP con fechas(UTC): ${dateToInyect1} y ${dateToInyect2}`, 0);    
                    const result = await request.query(`EXEC GetConversationDetailsByDate '${dateToInyect1}', '${dateToInyect2}';`);//'YYYY-MM-DD HH:MM:SS', 'YYYY-MM-DD HH:MM:DD';`);
                    if(result.recordset.length < 1){
                        throw new Error(`No se encontraron datos con la query `);
                    }
                    this.logEvent('INFO', `SP ejecutado con éxito, datos cargados en tabla exitosamente`, 0);
                    const rowsQuantity= result.recordset.length;
                    return {
                        "status": 200,
                        "message": `SP ejecutado con éxito, datos cargados en tabla exitosamente, ${rowsQuantity} filas insertadas`,
                    }
                }catch(e){
                    throw Error
                }
            });
        } catch (e) {
            this.logEvent('ERROR', `Error al ejecutar SP ${e}\n${JSON.stringify(e,null,4)}` , 0);    
            return{
                "status": 500,
                "message": `Error al ejecutar SP ${e}\n${JSON.stringify(e,null,4)}`,
            }
        }
    }
}


export default ExectSp;
const newExectSpClassObjt= new ExectSp;
const executor = newExectSpClassObjt.exectSp;
await executor();
 ```
 Modifique el sp y ahora el sp devuelve la informacion de las fechas ingresadas,
 ahora necesito cambiar esta clase para que antes de ejecutar el sp compruebe que este existe dentro de la dbN
 si no existe que lo cree dentro de la base de datos el sp se encuentra dentro de esta direccion dentro del codigo=__dirname,'..\static\sql-obj\sp.sql', luego que este sp realice la busqueda dentro del la db,
 la informacion resultante de la busqueda se debe guardar dentro de este modelo de mongo db =
 ``` js
import mongoose from 'mongoose';
import crypto from 'crypto';
import { chargeData } from '../lib/dotenvExtractor.js';
chargeData();
const { Schema } = mongoose;

const encryptionKey = process.argv[6];

if (encryptionKey.length !== 32) {
    throw new Error('Invalid encryption key length. Key must be 32 bytes.');
}

const encrypt = (text) => {
    const iv = crypto.randomBytes(16); // Initialization vector
    const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(encryptionKey, 'utf8'), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted; // Prepend IV for decryption
};

const decrypt = (text) => {
    const textParts = text.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedText = textParts.join(':');
    const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(encryptionKey, 'utf8'), iv);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
};

const historicalSchema = new Schema({
    SEARCHING_PERIOD: {
        type: String,
        required: true,
        unique: true,
        set: encrypt,
        get: decrypt
    },
    CLIENT_REPORT_DATA: [
        {
            CASE_ID: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            CONVERSATION_START: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            CONVERSATION_END: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            PARTICIPANT_ID: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            PARTICIPANT_NAME: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            ID_SESSION: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            EMAIL_ADDRESS_FROM: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            EMAIL_ADDRESS_TO: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            QUEUE_INTERACTION_INIT: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            QUEUE_INTERACTION_END: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            TOTAL_HOLD_TIME: {
                type: Number,
                required: true,
                set: encrypt,
                get: decrypt
            },
            CLIENT_INTERACTION_INIT: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            CLIENT_INTERACTION_END: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            TOTAL_CLIENT_INTERACTION_TIME: {
                type: Number,
                required: true,
                set: encrypt,
                get: decrypt
            },
            AGENT_INTERACTION_INIT: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            AGENT_INTERACTION_END: {
                type: Date,
                required: true,
                set: encrypt,
                get: decrypt
            },
            TOTAL_AGENT_INTERACTION_TIME: {
                type: Number,
                required: true,
                set: encrypt,
                get: decrypt
            },
            QUEUE_ID: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            QUEUE_NAME: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            SUBJECT: {
                type: String,
                required: true,
                set: encrypt,
                get: decrypt
            },
            TRANSFER_CALL: {
                type: Boolean,
                required: true,
                set: encrypt,
                get: decrypt
            },
            CASE_ENDED: {
                type: Boolean,
                required: true,
                set: encrypt,
                get: decrypt
            }
        }
    ]
}, { toJSON: { getters: true }, toObject: { getters: true } });

historicalSchema.index({ expiration_date: 1 }, { expireAfterSeconds: parseInt(1300000 / 2) }); // Cada 375 MB aprox

const historicalModel = mongoose.model('historical', historicalSchema);

export default historicalModel;
 ```
Luego necesito que al realizar la busqueda y al almacenar correctamente los datos se genere un objeto de reporte acá
=
``` js
import mongoose from 'mongoose';
 
const { Schema } = mongoose;

 

 
const reportSchema = new Schema({
    datesTFind: {
        type: String, // Cambiado a String para reflejar el formato en la base de datos
        required: true,
        unique: true    //select date
    },
    dateProcess: {
        type: Date,
        required: true  // time stamp exec
    },
    reportId: {
        type: String,
        required: true, // report id
        unique: true
    },
    state: {
        type: String,
        required: true  // estado
    },
    result: {
        type: String,
        required: true  // resultado  success/fail
    } 
});

// Index to automatically delete documents after 1 day
reportSchema.index({ expiration_date: 1 }, { expireAfterSeconds: 1300000 }); // Cada 750 MB aprox se limpian los datos en la db

const reportModel = mongoose.model('reports', reportSchema);

export  default  reportModel ;
```
